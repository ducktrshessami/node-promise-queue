{"version":3,"sources":["../src/index.ts","../src/PromiseQueueGroup.ts","../src/PromiseQueue.ts"],"sourcesContent":["export * from \"./PromiseQueue\";\nexport * from \"./PromiseQueueGroup\";\nexport { LazyPromise, PromiseOrLazy } from \"./util\";\n","import { PromiseOrLazy } from \"./util\";\n\nexport class PromiseQueueGroup<GroupTypes extends any[] = []> {\n    private readonly promises: GroupTypes;\n    private _all: Promise<GroupTypes> | null;\n\n    constructor() {\n        this.promises = [] as any as GroupTypes;\n        this._all = null;\n    }\n\n    public get all(): Promise<GroupTypes> {\n        this._all ??= Promise.all(this.promises);\n        return this._all;\n    }\n\n    protected push<T>(promise: Promise<T>): asserts this is PromiseQueueGroup<[...GroupTypes, T]> {\n        this.promises.push(promise);\n        this._all = null;\n    }\n\n    public resolveLazy<T>(promise: PromiseOrLazy<T>): Promise<T> {\n        return typeof promise === \"function\" ? this.all.then(promise) : promise;\n    }\n\n    public add<T>(promise: PromiseOrLazy<T>): asserts this is PromiseQueueGroup<[...GroupTypes, T]> {\n        const p = this.resolveLazy(promise);\n        this.push(p);\n    }\n\n    public clear(): asserts this is PromiseQueueGroup<[]> {\n        this.promises.length = 0;\n        this._all = null;\n    }\n}\n","import { PromiseQueueGroup } from \"./PromiseQueueGroup\";\nimport { GroupType, MergeGroup, PromiseOrLazy } from \"./util\";\n\nexport class PromiseQueue<GroupMap extends {} = {}, AllTypes extends any[] = []> extends PromiseQueueGroup<AllTypes> {\n    public static readonly DefaultGroup = \"default\";\n\n    private readonly groups: Map<string, PromiseQueueGroup> = new Map();\n\n    private ensureGroup<Group extends string>(name: Group): PromiseQueueGroup<GroupType<GroupMap, Group>> {\n        let group = this.groups.get(name);\n        if (!group) {\n            group = new PromiseQueueGroup();\n            this.groups.set(name, group);\n        }\n        return group as PromiseQueueGroup<GroupType<GroupMap, Group>>;\n    }\n\n    public add<T>(promise: PromiseOrLazy<T>): asserts this is PromiseQueue<MergeGroup<GroupMap, typeof PromiseQueue.DefaultGroup, T>, [...AllTypes, T]>;\n    public add<T, Group extends string>(promise: PromiseOrLazy<T>, groupName: Group): asserts this is PromiseQueue<MergeGroup<GroupMap, Group, T>, [...AllTypes, T]>;\n    public add<T>(promise: PromiseOrLazy<T>, groupName: string = PromiseQueue.DefaultGroup): void {\n        const group: PromiseQueueGroup<any[]> = this.ensureGroup(groupName);\n        const p = group.resolveLazy(promise);\n        group.add(p);\n        this.push(p);\n    }\n\n    public clear(): asserts this is PromiseQueue<{}, []> {\n        this.groups.forEach(group => group.clear());\n        this.groups.clear();\n        super.clear();\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,IAAM,oBAAN,MAAuD;AAAA,EACzC;AAAA,EACT;AAAA,EAER,cAAc;AACV,SAAK,WAAW,CAAC;AACjB,SAAK,OAAO;AAAA,EAChB;AAAA,EAEA,IAAW,MAA2B;AAClC,SAAK,SAAS,QAAQ,IAAI,KAAK,QAAQ;AACvC,WAAO,KAAK;AAAA,EAChB;AAAA,EAEU,KAAQ,SAA4E;AAC1F,SAAK,SAAS,KAAK,OAAO;AAC1B,SAAK,OAAO;AAAA,EAChB;AAAA,EAEO,YAAe,SAAuC;AACzD,WAAO,OAAO,YAAY,aAAa,KAAK,IAAI,KAAK,OAAO,IAAI;AAAA,EACpE;AAAA,EAEO,IAAO,SAAkF;AAC5F,UAAM,IAAI,KAAK,YAAY,OAAO;AAClC,SAAK,KAAK,CAAC;AAAA,EACf;AAAA,EAEO,QAA+C;AAClD,SAAK,SAAS,SAAS;AACvB,SAAK,OAAO;AAAA,EAChB;AACJ;;;AC/BO,IAAM,eAAN,MAAM,sBAA4E,kBAA4B;AAAA,EACjH,OAAuB,eAAe;AAAA,EAErB,SAAyC,oBAAI,IAAI;AAAA,EAE1D,YAAkC,MAA4D;AAClG,QAAI,QAAQ,KAAK,OAAO,IAAI,IAAI;AAChC,QAAI,CAAC,OAAO;AACR,cAAQ,IAAI,kBAAkB;AAC9B,WAAK,OAAO,IAAI,MAAM,KAAK;AAAA,IAC/B;AACA,WAAO;AAAA,EACX;AAAA,EAIO,IAAO,SAA2B,YAAoB,cAAa,cAAoB;AAC1F,UAAM,QAAkC,KAAK,YAAY,SAAS;AAClE,UAAM,IAAI,MAAM,YAAY,OAAO;AACnC,UAAM,IAAI,CAAC;AACX,SAAK,KAAK,CAAC;AAAA,EACf;AAAA,EAEO,QAA8C;AACjD,SAAK,OAAO,QAAQ,WAAS,MAAM,MAAM,CAAC;AAC1C,SAAK,OAAO,MAAM;AAClB,UAAM,MAAM;AAAA,EAChB;AACJ;","names":[]}